# 远程控制系统说明

## 系统架构

```
客户端 (Windows) <---> 服务器 (CentOS) <---> 控制端
    |                       |                    |
    |-- 5003: 屏幕共享 -----|                    |
    |-- 5004: 命令接收 -----|--------------------+
```

## 功能特性

### 1. 屏幕共享控制
- 通过 5003 端口接收开启/停止命令
- 开启时：发送屏幕右侧 1/4 区域（4 FPS）
- 停止时：不发送屏幕数据

### 2. Kiro 命令执行
- 通过 5004 端口接收文本命令
- 自动查找并激活 Kiro 窗口
- 移动鼠标到输入框位置 (1228, 720)
- 输入命令文本并按回车

## 使用方法

### 客户端（被控制端）

#### Windows 启动
```bash
# 使用脚本
启动远程控制.bat

# 或手动运行
python remote_control_client.py
```

#### 自定义参数
```bash
python remote_control_client.py [服务器IP] [屏幕端口] [命令端口]

# 示例
python remote_control_client.py 111.170.6.103 5003 5004
```

### 服务器端（控制端）

#### 启动命令服务器
```bash
# CentOS 服务器
python3 remote_control_server.py

# 自定义端口
python3 remote_control_server.py 5004
```

#### 发送命令

启动后会进入命令行界面：

```
>>> start          # 开启屏幕共享
>>> stop           # 停止屏幕共享
>>> input 继续     # 在 Kiro 中输入"继续"
>>> clients        # 显示连接的客户端
>>> quit           # 退出
```

## 命令格式

### 屏幕控制命令
```json
{
  "type": "screen_control",
  "action": "start"  // 或 "stop"
}
```

### Kiro 输入命令
```json
{
  "type": "kiro_input",
  "text": "继续"
}
```

## 配置说明

### 修改 Kiro 输入位置

编辑 `remote_control_client.py`：

```python
# 修改这一行
self.kiro_input_position = (1228, 720)
```

### 修改屏幕捕获区域

编辑 `remote_control_client.py` 中的 `get_screen_region()` 方法。

### 修改帧率

编辑 `remote_control_client.py`：

```python
config = {
    'fps': 4,  # 修改这里
    ...
}
```

## 部署步骤

### 1. 服务器端（CentOS）

```bash
# 上传文件
scp remote_control_server.py user@111.170.6.103:~/

# SSH 连接
ssh user@111.170.6.103

# 启动命令服务器
python3 remote_control_server.py

# 后台运行
nohup python3 remote_control_server.py > control.log 2>&1 &
```

### 2. 开放防火墙端口

```bash
# 开放 5004 端口（命令端口）
sudo firewall-cmd --permanent --add-port=5004/tcp
sudo firewall-cmd --reload

# 检查
sudo firewall-cmd --list-ports
```

### 3. 客户端（Windows）

```bash
# 安装依赖
pip install -r requirements.txt

# 启动
启动远程控制.bat
```

## 使用场景

### 场景 1: 远程协助

1. 客户端启动远程控制
2. 服务器发送 `start` 开启屏幕共享
3. 查看客户端屏幕
4. 发送 `input <命令>` 在 Kiro 中执行操作
5. 完成后发送 `stop` 停止屏幕共享

### 场景 2: 自动化任务

1. 客户端保持运行
2. 服务器定时发送命令
3. 客户端自动执行

### 场景 3: 批量控制

1. 多个客户端连接到服务器
2. 服务器广播命令
3. 所有客户端同时执行

## 故障排除

### 客户端无法连接

1. 检查服务器是否启动
2. 检查防火墙设置
3. 检查网络连通性：`ping 111.170.6.103`
4. 检查端口：`telnet 111.170.6.103 5004`

### Kiro 输入失败

1. 确认 Kiro 窗口已打开
2. 检查输入位置是否正确
3. 手动测试：`python kiro_auto_input.py`
4. 调整 `kiro_input_position` 坐标

### 屏幕共享不工作

1. 确认已发送 `start` 命令
2. 检查 5003 端口的屏幕共享服务器是否运行
3. 查看客户端日志

## 安全建议

1. **使用 VPN**：不要直接暴露端口到公网
2. **添加认证**：修改代码添加密码验证
3. **加密传输**：使用 SSL/TLS
4. **限制 IP**：防火墙只允许特定 IP 访问

## 扩展功能

可以添加的功能：

- [ ] 身份验证
- [ ] 加密传输
- [ ] 命令历史记录
- [ ] 多客户端管理
- [ ] Web 控制界面
- [ ] 文件传输
- [ ] 鼠标键盘完整控制
- [ ] 屏幕录制

## 技术细节

### 通信协议

所有数据包格式：`[4字节长度][JSON数据]`

- 长度：网络字节序（big-endian）
- 数据：UTF-8 编码的 JSON

### 线程模型

客户端使用 3 个线程：
1. 主线程：管理生命周期
2. 屏幕共享线程：连接 5003，发送屏幕
3. 命令接收线程：连接 5004，接收命令

### 状态管理

- `screen_sharing_enabled`：控制是否发送屏幕
- `running`：控制整体运行状态
